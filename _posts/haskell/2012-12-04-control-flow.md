---
layout: post
category: haskell
author: neizod
---
{% include JB/setup %}

ค่าความจริงใน Haskell มีเพียงแค่ `True` กับ `False` เท่านั้น (ไม่สามารถใช้ `0` หรือค่าว่างแบบอื่นๆ แทน `False` ได้)

ฟังก์ชันสำหรับตรวจสอบความเท่ากัน ใช้ `==` (เท่ากัน) กับ `/=` (ไม่เท่ากัน) ส่วนฟังก์ชันสำหรับการตรวจสอบลำดับก็ได้แก่ `<=` (น้อยกว่าเท่ากับ), `<` (น้อยกว่า), `>` (มากกว่า), `>=` (มากกว่าเท่ากับ)

```haskell
    ghci> 1 == 1
    True
    ghci> 0 /= 42
    True
```

logic สำหรับเชื่อมค่าความจริงเหล่านี้ได้แก่ `&&` (และ), `||` (หรือ), `not` (นิเสธ)

```haskell
    ghci> let x = 42
    ghci> 1 < x && x <= 100
    True
```

สาเหตุที่นิเสธไม่ใช้สัญลักษณ์เช่นเดียวกับการดำเนินการอื่นๆ เพราะฟังก์ชันใน Haskell จะเขียนแทนด้วยสัญลักษณ์ได้ มันต้องเป็นฟังก์ชัน 2 ตัวแปรและทำหน้าที่เป็น infix เท่านั้นครับ

---

ด้วยความที่เป็นภาษา functional ทุกๆ expression จะต้องคืนค่ากลับมาเสมอ ทำให้การใช้ if ใน Haskell ต้องมีส่วน else ตามท้ายตลอด

```haskell
    ghci> let x = -3.0
    ghci> if x /= 0 then log (abs x) else 0
    1.0986122886681098
```

ถ้าต้องการใช้แค่ if อย่างเดียว และบังคับโปรแกรมให้หยุดทำงานเมื่อเจอเงื่อนไขที่ผิด ก็สามารถใช้ฟังก์ชัน `error` แบบนี้แทนได้

```haskell
    ghci> let x = 0.0
    ghci> if x /= 0 then log (abs x) else error "log zero!"
    *** Exception: log zero!
```

ตัวอย่างข้างต้นนี้สามารถแยกเขียนหลายบรรทัดให้อ่านง่ายขึ้นได้ แต่เนื่องจาก `ghci` ไม่สะดวกเมื่อต้องเขียนหลายบรรทัด จะย้ายไปเขียนเป็นฟังก์ชันในไฟล์แทน ดังนี้

```haskell
    logAbs x = if x /= 0
        then log (abs x)
        else error "log zero!"
```

สิ่งที่ต่างไปจากการประกาศฟังก์ชันบน `ghci` คือ ไม่ต้องมี `let` นำหน้า เนื่องจากฟังก์ชันนี้ไม่ได้ถูกประกาศใน `main` ครับ

เซฟเป็นไฟล์ `func.hs` แล้วกลับมาที่ `ghci` เราจะเรียกฟังก์ชันที่เขียนเก็บด้วยคำสั่ง `:l` หรือ `:load` ดังนี้

```haskell
    ghci> :l func.hs 
    [1 of 1] Compiling Main             ( func.hs, interpreted )
    Ok, modules loaded: Main.
    ghci> logAbs (-3)
    1.0986122886681098
```
